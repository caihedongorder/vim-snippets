# cs.snippets
# ===========
#
# Standard C-Sharp snippets for snipmate.
#
# Largely ported over from Visual Studio 2010 snippets plus
# a few snippets from Resharper plus a few widely known snippets.
#
# Most snippets on elements (i.e. classes, properties)
# follow suffix conventions. The order of suffixes to a snippet
# is fixed.
#
# Snippet Suffix Order
# --------------------
# 1. Access Modifiers
# 2. Class Modifiers
#
# Access Modifier Suffix Table
# ----------------------------
# + = public
# & = internal
# | = protected
# - = private
#
# Example: `cls&` expands to `internal class $1`.
# Access modifiers might be doubled to indicate
# different modifiers for get/set on properties.
# Example: `pb+-` expands to `public bool $1 { get; private set; }`
#
# Class Modifier Table
# --------------------
# ^ = static
# % = abstract
#
# Example: `cls|%` expands to `protected abstract class $1`
#
# On method and property snippets, you can directly set
# one of the common types int, string and bool, if desired,
# just by appending the type modifier.
#
# Type Modifier Table
# -------------------
# i = integer
# s = string
# b = bool
#
# Example: `pi+&` expands to `public int $1 { get; internal set; }`
#
# I'll most propably add more stuff in here like
# * List/Array constructio
# * Mostly used generics
# * Linq
# * Funcs, Actions, Predicates
# * Lambda
# * Events
#
# Feedback is welcome!
#
# Main
snippet sim
${1:public} static int Main(string[] args)
{
	${0}
	return 0;
}
endsnippet
snippet simc
public class Application
{
	${1:public} static int Main(string[] args)
	{
		${0}
		return 0;
	}
}
endsnippet
snippet svm
${1:public} static void Main(string[] args)
{
	${0}
}
endsnippet
# if condition
snippet if
if (${1:true})
{
	${0:${VISUAL}}
}
endsnippet
snippet el
else
{
	${0:${VISUAL}}
}
endsnippet
snippet ifs
if (${1})
	${0:${VISUAL}}
endsnippet
# ternary conditional
snippet t
${1} ? ${2} : ${0}
endsnippet
snippet ?
${1} ? ${2} : ${0}
endsnippet
# do while loop
snippet do
do
{
	${0:${VISUAL}}
} while (${1:true});
endsnippet
# while loop
snippet wh
while (${1:true})
{
	${0:${VISUAL}}
}
endsnippet
# for loop
snippet for
for (int ${1:i} = 0; $1 < ${2:count}; $1${3:++})
{
	${0}
}
endsnippet
snippet forr
for (int ${1:i} = ${2:length}; $1 >= 0; $1--)
{
	${0}
}
endsnippet
# foreach
snippet fore
foreach (${1:var} ${2:entry} in ${3})
{
	${0}
}
endsnippet
snippet foreach
foreach (${1:var} ${2:entry} in ${3})
{
	${0}
}
endsnippet
snippet each
foreach (${1:var} ${2:entry} in ${3})
{
	${0}
}
endsnippet
# interfaces
snippet interface
public interface ${1:`vim_snippets#Filename()`}
{
	${0}
}
endsnippet
snippet if+
public interface ${1:`vim_snippets#Filename()`}
{
	${0}
}
endsnippet
# class bodies
snippet cls
${2:public} class ${1:`vim_snippets#Filename()`}
{
	${0}
}
endsnippet
# constructor
snippet ctor
public ${1:`vim_snippets#Filename()`}()
{
	${0}
}
endsnippet
# properties - auto properties by default.
# default type is int with layout get / set.
# structure
snippet struct
public struct ${1:`vim_snippets#Filename()`}
{
	${0}
}
endsnippet
# enumeration
snippet enum
enum ${1}
{
	${0}
}
endsnippet

snippet enum+
public enum ${1}
{
	${0}
}
endsnippet
# preprocessor directives
snippet #if
#if
	${0}
#endif
endsnippet
# inline xml documentation
snippet ///
/// <summary>
/// ${0}
/// </summary>
endsnippet
snippet <p
<param name="${1}">${2:$1}</param>
endsnippet
snippet <ex
<exception cref="${1:System.Exception}">${2}</exception>
endsnippet
snippet <r
<returns>${1}</returns>
endsnippet
snippet <s
<see cref="${1}"/>
endsnippet
snippet <rem
<remarks>${1}</remarks>
endsnippet
snippet <c
<code>${1}</code>
endsnippet

snippet cw
Console.WriteLine(${1});
endsnippet

# equals override
snippet eq
public override bool Equals(object obj)
{
	if (obj == null || GetType() != obj.GetType())
	{
		return false;
	}
	${0:throw new NotImplementedException();}
	return base.Equals(obj);
}
endsnippet
# exception
snippet exc
public class ${1:MyException} : ${2:Exception}
{
	public $1() { }
	public $1(string message) : base(message) { }
	public $1(string message, Exception inner) : base(message, inner) { }
	protected $1(
		System.Runtime.Serialization.SerializationInfo info,
		System.Runtime.Serialization.StreamingContext context)
			: base(info, context) { }
}
endsnippet
# indexer
snippet index
public ${1:object} this[${2:int} index]
{
	get { ${0} }
	set { ${0} }
}
endsnippet
# eventhandler
snippet inv
EventHandler temp = ${1:MyEvent};
if (${2:temp} != null)
{
	$2();
}
endsnippet
# lock
snippet lock
lock (${1:this})
{
	${0}
}
endsnippet
# namespace
snippet ns
namespace ${1:MyNamespace}
{
	${0}
}
endsnippet
# switch
snippet switch
switch (${1:switch_on})
{
	${0}
	default:
}
endsnippet
# try
snippet try
try
{
	${0:${VISUAL}}
}
catch (${1:System.Exception})
{
	throw;
}
endsnippet
snippet tryf
try
{
	${0:${VISUAL}}
}
finally
{
	${1}
}
endsnippet
# using
snippet usi
using (${1:resource})
{
	${0}
}
endsnippet


#######################################################################
#                             c# property                             #
#######################################################################
global !p
def cs_gettype(shorttype):
	if shorttype == "v":
		return "void"
	elif shorttype == "b":
		return "bool"
	if shorttype == "sb":
		return "sbyte"
	elif shorttype == "by":
		return "byte"
	elif shorttype == "sh":
		return "short"
	elif shorttype == "us":
		return "ushort"
	elif shorttype == "i":
		return "int"
	elif shorttype == "ui":
		return "uint"
	elif shorttype == "l":
		return "long"
	elif shorttype == "ul":
		return "ulong"
	elif shorttype == "f":
		return "float"
	elif shorttype == "d":
		return "double"
	elif shorttype == "s":
		return "string"
	elif shorttype == "img":
		return "UImage"
	elif shorttype == "btn":
		return "UButton"
	elif shorttype == "sli":
		return "USlider"
	elif shorttype == "combo":
		return "UComboBox"
	elif shorttype == "prog":
		return "UProgressBar"
	else:
		if isinstance(shorttype,str) and len(shorttype) > 1:
			if shorttype[0] == 'l' : 
				elemType = cs_gettype(shorttype[2:])
				return "List<"+ elemType + ">"
			elif shorttype[0] == 'd' :
				keyValueStr = shorttype[2:]
				strkeyElemType,strValueElelType = keyValueStr.split('.',1)
				keyElemType = cs_gettype(strkeyElemType)
				valueElemType = cs_gettype(strValueElelType)
				print(keyElemType,valueElemType)
				return "Dictionary< " + keyElemType + " , " + valueElemType + " >"
			
	return shorttype
def cs_getTypePrefix(shorttype):
	if shorttype == "img":
		return "Image_"
	elif shorttype == "btn":
		return "Button_"
	elif shorttype == "sli":
		return "Slider_"
	elif shorttype == "combo":
		return "ComboBox_"
	elif shorttype == "prog":
		return "Progressbar_"
	return ""
def cs_getAccessString(shortAccessStr):
	if shortAccessStr == "p":
		return "public"
	elif shortAccessStr == "r":
		return "protected"
	elif shortAccessStr == "i":
		return "private"
	return "public"
def cs_getFuncParams(shorttype):
	params = shorttype.split('.')
	if len(params) == 2 :
		funcName = params[0]
		retValue = cs_gettype( params[1] )
		return retValue + " " + funcName + "()"
	elif len(params) > 2 :
		funcName = params[0]
		retValue = cs_gettype( params[1] )
		strParams = "("
		startIdx = 2
		while startIdx + 1 < len(params) :
			strParamType = cs_gettype(params[startIdx])
			strParamName = params[startIdx + 1]
			strParams += strParamType + " " + strParamName;
			startIdx = startIdx + 2
			if startIdx + 1 < len(params) :
				strParams += ","
		strParams += ")"
		return retValue + " " + funcName + strParams
	return shorttype
def cs_ExtractAnVariable(var2Extract):
	""" to extract an varible 
		ex: a.b.c => var c = a.b.c;
		:var2Extract: identifies joined by '.'
	"""
	identifies = var2Extract.split('.')
	numIdentifies = len(identifies)
	return 'var ' + identifies[numIdentifies-1] + ' = ' + var2Extract + ';'
endglobal

################
#  assignment  #
################
snippet "\bass\.(\w+)" "assignment" r
this.${1:`!p snip.rv = match.group(1)`} = $1;$0
endsnippet

######################
#  property snippet  #
######################
snippet "\bprop\.([a-zA-Z_\d\.]+)\b" "define a property" r
public `!p snip.rv = cs_gettype(match.group(1))` `!p snip.rv = cs_getTypePrefix(match.group(1))`${1:propName} { get; set; }${0}
endsnippet


######################
#  variable snippet  #
######################
snippet "\bvar([pri]?)\.([a-zA-Z_\d\.]+)\b" "define a variable" r
`!p snip.rv = cs_getAccessString(match.group(1))` `!p snip.rv = cs_gettype(match.group(2))` `!p snip.rv = cs_getTypePrefix(match.group(2))`${1:propName};${0}
endsnippet
######################
#  variable snippet  #
######################
snippet "\bvarn([pri]?)\.([a-zA-Z_\d\.]+)\b" "define a variable and new" r
`!p snip.rv = cs_getAccessString(match.group(1))` `!p snip.rv = cs_gettype(match.group(2))` `!p snip.rv = cs_getTypePrefix(match.group(1))`${2:propName} = new `!p snip.rv = cs_gettype(match.group(2))`();${0}
endsnippet



###################
#  class snippet  #
###################
snippet "\bc([pri]?)\.([a-zA-Z_.]+)\b" "" r
`!p snip.rv = cs_getAccessString(match.group(1))` class `!p snip.rv = match.group(2)`
{
	${1}
}${0}
endsnippet


##########################################
#  for quickly to generate functionSnip  #
##########################################

snippet "\bf" "" r
${1:f}.${2:funcName}.${3:v}${0}
endsnippet

snippet "\bf1" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}${0}
endsnippet

snippet "\bf2" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}${0}
endsnippet

snippet "\bf3" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}${0}
endsnippet

snippet "\bf4" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}${0}
endsnippet

snippet "\bf5" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}${0}
endsnippet

snippet "\bf6" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}.${12:type}.${13:Name}${0}
endsnippet

snippet "\bf7" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}.${12:type}.${13:Name}.${14:type}.${15:Name}${0}
endsnippet

snippet "\bf8" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}.${12:type}.${13:Name}.${14:type}.${15:Name}.${16:type}.${17:Name}${0}
endsnippet

snippet "\bf9" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}.${12:type}.${13:Name}.${14:type}.${15:Name}.${16:type}.${17:Name}.${18:type}.${19:Name}${0}
endsnippet

snippet "\bf10" "" r
${1:f}.${2:funcName}.${3:v}.${4:type}.${5:Name}.${6:type}.${7:Name}.${8:type}.${9:Name}.${10:type}.${11:Name}.${12:type}.${13:Name}.${14:type}.${15:Name}.${16:type}.${17:Name}.${18:type}.${19:Name}.${20:type}.${21:Name}${0}
endsnippet

#######################
#  function snippets  #
#######################

snippet "\bf([pri]?)\.([\w\d\.]+)\b" "" r
`!p snip.rv = cs_getAccessString(match.group(1))` `!p snip.rv = cs_getFuncParams( match.group(2) )`
{
	${1}
}${0}
endsnippet

#######################################################################
#                            ulti snippets                            #
#######################################################################

snippet "([\w.()]+)\.s" "expands an variable like var:{var}" r
`!p snip.rv = match.group(1) + ':' "{ " + match.group(1) + " }"`$0
endsnippet

snippet "([\w.]+)\.e" "extract an variable" r
`!p snip.rv = cs_ExtractAnVariable( match.group(1) )`
endsnippet


#######################################################################
#                           string snippets                           #
#######################################################################

snippet s.def "define a string" b
${1:result} = "${2:string}";
$0
endsnippet

snippet s.if "check if str1 str2 is equal" w
if(${1:str1}${2:==}${3:str2})
{
	$0
}
endsnippet

snippet s.concat "string concat" w
${1:result} = ${2:str1} + ${3:str2};
$0
endsnippet

snippet s.copy "string copy" w
${1:result} = String.copy(${2:str2Copy});
endsnippet

snippet s.format "string format" w
\$"$1"$0
endsnippet


snippet s.substring "get sub string" b
${1:result} = ${2:str}.Substring( ${3:startIndex} , ${4: count} );$0
endsnippet


snippet s.contains "check if string contains substr" w
String.Contains(${2:subStr})
endsnippet

snippet s.startswith "check if string end with" w
${1:str}.StartsWith( ${2:startStr} )
endsnippet
snippet s.endswith "check if string end with" w
${1:str}.EndsWith(${2:endStr})
endsnippet

snippet s.index "indexof substr or char" w
${1:str}.IndexOf( ${2:subStrOfChar} )
endsnippet

snippet s.lastindex "lastindexof substr or char" w
${1:str}.LastIndexOf( ${2:subStrOfChar} )
endsnippet

snippet s.join "string join" b
${1:result} = String.Join( '${2:sep}' , ${3:strArr} );
$0
endsnippet

snippet s.remove "string remove" w
${1:result} = ${2:str}.Remove( ${3:start} , ${4:count} );
endsnippet

snippet s.upper "convert string to upper" w
${1:result} = ${2:str}.ToUpper(); 
$0
endsnippet

snippet s.lower "convert string to upper" w
${1:result} = ${2:str}.ToLower(); 
$0
endsnippet

snippet s.trim "trim a string" w
${1:result} = ${2:str}.Trim();
$0
endsnippet

snippet s.split "split a string into an array" b
${1:result} = ${2:str}.Split( '${3:,}' );
$0
endsnippet

snippet s.split.2 "split a string into an array" b
${1:result} = ${2:str}.Split( '${3:,}');
var ${4:left} = $1[0];
var ${5:right} = $1[1];
$0
endsnippet

snippet s.split.2.r "split a string into an array" b
${1:sepPos} = ${2:str}.rfind(${3:,})
if ($1 != -1)
{
	var ${4:left} = $2.Substring( 0 , $1 );
	var ${5:right} = $2.Substring( $1 + 1 );
	$0
}

endsnippet

snippet s.reg "string sample" b
/*
private static void showMatch(string text, string expr)
{
	Console.WriteLine("The Expression: " + expr);
	MatchCollection mc = Regex.Matches(text, expr);
	foreach (Match m in mc)
	{
		Console.WriteLine(m);
	}
}
static void Main(string[] args)
{
	string str = "make maze and manage to measure it";
	
	Console.WriteLine("Matching words start with 'm' and ends with 'e':");
	showMatch(str, @"\bm\S*e\b");
	Console.ReadKey();
}
*/
endsnippet


#######################################################################
#                            array snippet                            #
#######################################################################
snippet arr.def "define an array" b
${1:int}[] ${2:arrName} = new $1[${3:count}]
{
	$4
};
$0
endsnippet

# string[] arrName = new # string[]
# {
#     "test1",
#     "test2",
#     "test3",
# };

snippet arr.for "arr forloop" b
for (int ${1:index} = 0; $1 < ${2:arr}.Length; $1++)
{
	var ${3:element} = $2[$1];
	${VISUAL}
	$3
}
$0
endsnippet

snippet arr.foreach "arr for each" b
foreach (var ${1:element} in ${2:arr})
{
	${VISUAL}
	$3
}
$0
endsnippet

snippet arr.find "find an element" b
${1:elementType} ${2:findedElem} = $1();
foreach (var ${3:element} in ${4:arr})
{
	if (${5:condition})
	{
		$2 = $3;
		break;
	}
}
$0
endsnippet

snippet arr.get "get an element by index" b
var ${1:targetValue} = ${2:arr}[${3:index}];
$0
endsnippet

snippet arr.set "set an element value" b
${1:arr}[${2:index}] = ${3:value};
$0
endsnippet

#######################################################################
#                            list snippet                             #
#######################################################################
snippet "l.def.([\w]+)" "define a list and new" r
List<${1:`!p snip.rv = cs_gettype(match.group(1))`}> ${2:varName};$0
endsnippet

snippet "l.def.new.([\w]+)" "define a list and new" r
List<${1:`!p snip.rv = cs_gettype(match.group(1))`}> ${2:varName} = new List<$1>(){$3 };
$0
endsnippet


snippet l.len "length of list" b
var ${1:length } = ${2:list }.Count;
endsnippet

snippet l.len.only "length of list" w
${2:list}.Count$0
endsnippet

snippet l.get.only "get element by index" w
${1:list}[${2:index}]$0
endsnippet

snippet l.get "length of list" b
var ${1:varName} = ${2:list}[${3:index}]$0
endsnippet

snippet l.get.range "get a range of element into a list" b
var ${1:newList} = ${2:list}.GetRange(${3:startIndex} , ${4:count});
$0
endsnippet

snippet l.set "set element of list value" 
${1:list}[${2:index}] = ${3:value};
endsnippet

snippet l.for "for loop" b
for (var ${1:iList} = 0; $1 < ${2:list}.Count ; $1++)
{
	var cur${3:Element} = $2[$1];
	${4}	
}
$0
endsnippet



snippet l.foreach "for each" b
foreach (var ${1:element} in ${2:list})
{
	$3
}
$0
endsnippet

snippet l.add "add an element to a list" b
${1:list}.Add(${2:element});
$0
endsnippet

snippet l.insert "insert an element to a list" b
${1:list}.Insert(${2:Index} , ${3:element});
endsnippet

snippet l.insert.range "insert a collection into a list" b
${1:list}.InsertRange(${2:startIndex} , ${3:list2Insert});
$0
endsnippet

snippet l.remove "remove an element" b
${1:list}.Remove(${2:element});
$0
endsnippet

snippet l.remove.at "remove an element by index" b
${1:list}.RemoveAt(${2:index});
$0
endsnippet

snippet l.remove.range "remove an element by index" b
${1:list}.RemoveRange(${2:startIndex},${3:Count});
$0
endsnippet

snippet l.contains "check if a list cantaint a element" b
${1:list}.Contains(${2:element})$0
$0
endsnippet

snippet l.sort "sort a list" b
${1:list}.Sort((x,y)=>{
	${2:return -1;}
});
$0
endsnippet

snippet l.exist "check if there is any element in a list" w
${1:list}.Exists( (x) => {
	${2:return false;}
})
endsnippet

snippet l.exist.simple "check if there is any element in a list" w
${1:list}.Exists( x => ${2:expr})$0
endsnippet

snippet l.orderby "order by to list" b
var ${1:orderedList} = ${2:list}.OrderBy(x=>${3:x.id}).ToList();
$0
endsnippet

snippet l.index "get index of an element in a list" b
var ${1:index} = ${2:list}.IndexOf( ${3:element} , ${4:startIndex} );
$0
endsnippet

snippet l.clear "clear a list" b
${1:list}.Clear();
$0
endsnippet

snippet l.reverse "reverse a list" b
${1:list}.Reverse();
$0
endsnippet

snippet l.find "find a element by predicate" b
var ${1:result} = ${2:list}.Find( ( x ) => {
	$0
});
endsnippet

snippet l.findall "find a sub list by predicate" b
var ${1:result} = ${2:list}.FindAll( ( x ) => {
	$0
});
endsnippet

snippet "l.find.min.(\w+)" "find a min element" r
// ${1:desc}
var ${2:minValue} = `!p snip.rv = cs_gettype(match.group(1))`.MaxValue;
var $2_Index = -1;
for (var ${3:index} = 0; $3 < ${4:list}.Count ; $3++)
{
	var ${5:curElement} = $4[$3];
	
	var curEvalValue = ${6:<++++>} ;

	if (curEvalValue < $2)
	{
		$2 = curEvalValue;
		$2_Index = $3 ;
	}
}
if ($2_Index != -1)
{
	var ${7:maxElement} = $4[ $2_Index ];
	$8
}
$0
endsnippet

snippet "l.find.max.(\w+)" "find a min element" r
// ${1:desc}
var ${2:maxValue} = `!p snip.rv = cs_gettype(match.group(1))`.MinValue;
var $2_Index = -1;
for (var ${3:index} = 0; $3 < ${4:list}.Count ; $3++)
{
	var ${5:curElement} = $4[$3];
	
	var curEvalValue = ${6:<++++>} ;

	if (curEvalValue > $2)
	{
		$2 = curEvalValue;
		$2_Index = $3 ;
	}
}
if ($2_Index != -1)
{
	var ${7:maxElement} = $4[ $2_Index ];
	$8
}
$0
endsnippet



snippet l.findlast "find a element by predicate from end" b
var ${1:result} = ${2:list}.FindLast( ( x ) => {
	$0
});
endsnippet

snippet l.findindex "find and index of a element by predicate" b
var ${1:result} = ${2:list}.FindIndex( ( x ) => {
	$0
});
endsnippet

snippet l.findindex.range "find an index of a element by predicate in a range" b
var ${1:result} = ${2:list}.FindIndex( ${3:startIndex} , ${4:count} , ( x ) => {
	$0
});
endsnippet

snippet l.findlastindex.range "find an index of a element by predicate from end in a range" b
var ${1:result} = ${2:list}.FindLastIndex( ${3:startIndex} , ${4:count} , ( x ) => {
	$0
});
endsnippet

snippet l.binarysearch "binary search an element from a list" b
var ${1:result} = ${2:list}.BinarySearch(${3:elelmentToSearch});
$0
endsnippet



#######################################################################
#                            dict snippets                            #
#######################################################################
snippet "d.def.([\w]+).([\w]+)" "define a dict " r
Dictionary<`!p snip.rv = cs_gettype(match.group(1))`, `!p snip.rv = cs_gettype(match.group(2))`> ${3:varName};
$0
endsnippet


snippet "d.def.new.([\w]+).([\w]+)" "define a dict and new" r
Dictionary<`!p snip.rv = cs_gettype(match.group(1))`, `!p snip.rv = cs_gettype(match.group(2))`> ${3:varName} = new Dictionary<`!p snip.rv = cs_gettype(match.group(1))`, `!p snip.rv = cs_gettype(match.group(2))`>();
$0
endsnippet

snippet d.get "get an element from a dict" w
var ${1:element} = ${2:dict}[${3:key}];
$0
endsnippet

snippet d.get.only "get an element from a dict" b
${1:dict}[${2:key}]$0
endsnippet

snippet d.get.try "try to get an element form a dict" b
if (${1:dict}.TryGetValue(${2:key} , out var ${3:outValue}))
{
	$4
}
$0
endsnippet

snippet d.set "set an value of dict" b
${1:dict}[${2:key}] = ${3:value};
$0
endsnippet

snippet d.add "add an element into a dict" b
${1:dict}.Add( ${2:key} , ${3:value} );
$0
endsnippet

snippet d.clear "clear a dict" b
${1:dict}.Clear();
$0
endsnippet

snippet d.containsKey "check if a dict contains a key" b
${1:dict}.ContainsKey(${2:key})$0
endsnippet

snippet d.containsValue "check if a dict contains a value" b
${1:dict}.ContainsValue(${2:value})$0
endsnippet

snippet d.remove "remove a key from dict" b
${1:dict}.Remove(${2:key});
$0
endsnippet

snippet d.foreach "for loop" b
foreach (var ${1:keyValuePairs} in ${2:dict})
{
	var ${3:Key} = $1.Key;
	var ${4:Value} = $1.Value;
	$5
}
$0
endsnippet

snippet d.foreach.remove "for loop to run remove finish task" b
List<${1:KeyType}> ${2:keys2Remove} = new List<$1>();
foreach (var ${3:keyValuePairs} in ${3:dict})
{
	var ${5:Key} = $1.Key;
	var ${6:Value} = $1.Value;
	$7
}
foreach (var ${8:element2Remove} in $2)
{
	$3.Remove($8);
}
$0
endsnippet

# public int propName { get; set; } 
# public byte propName { get; set; }

# public ushort propName { get; set; }
# public short propName { get; set; }
# public int propName { get; set; }
# public uint propName { get; set; }
# public long propName { get; set; }
# public ulong propName { get; set; }
# public float propName { get; set; }
# public double propName { get; set; }

